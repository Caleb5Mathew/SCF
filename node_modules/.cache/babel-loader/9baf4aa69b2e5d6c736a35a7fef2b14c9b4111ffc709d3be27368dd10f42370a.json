{"ast":null,"code":"import _toConsumableArray from\"C:/Users/caleb/VSchildren/SCF/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";// array in local storage for registered users\nvar users=JSON.parse(localStorage.getItem('users'))||[];export function configureFakeBackend(){var realFetch=window.fetch;window.fetch=function(url,opts){return new Promise(function(resolve,reject){// wrap in timeout to simulate server api call\nsetTimeout(function(){// authenticate\nif(url.endsWith('/users/authenticate')&&opts.method==='POST'){// get parameters from post request\nvar params=JSON.parse(opts.body);// find if any user matches login credentials\nvar filteredUsers=users.filter(function(user){return user.username===params.username&&user.password===params.password;});if(filteredUsers.length){// if login details are valid return user details and fake jwt token\nvar user=filteredUsers[0];var responseJson={id:user.id,username:user.username,firstName:user.firstName,lastName:user.lastName,token:'fake-jwt-token'};resolve({ok:true,text:function text(){return Promise.resolve(JSON.stringify(responseJson));}});}else{// else return error\nreject('Username or password is incorrect');}return;}// get users\nif(url.endsWith('/users')&&opts.method==='GET'){// check for fake auth token in header and return users if valid, this security is implemented server side in a real application\nif(opts.headers&&opts.headers.Authorization==='Bearer fake-jwt-token'){resolve({ok:true,text:function text(){return Promise.resolve(JSON.stringify(users));}});}else{// return 401 not authorised if token is null or invalid\nreject('Unauthorised');}return;}// get user by id\nif(url.match(/\\/users\\/\\d+$/)&&opts.method==='GET'){// check for fake auth token in header and return user if valid, this security is implemented server side in a real application\nif(opts.headers&&opts.headers.Authorization==='Bearer fake-jwt-token'){// find user by id in users array\nvar urlParts=url.split('/');var id=parseInt(urlParts[urlParts.length-1]);var matchedUsers=users.filter(function(user){return user.id===id;});var _user=matchedUsers.length?matchedUsers[0]:null;// respond 200 OK with user\nresolve({ok:true,text:function text(){return JSON.stringify(_user);}});}else{// return 401 not authorised if token is null or invalid\nreject('Unauthorised');}return;}// register user\nif(url.endsWith('/users/register')&&opts.method==='POST'){// get new user object from post body\nvar newUser=JSON.parse(opts.body);// validation\nvar duplicateUser=users.filter(function(user){return user.username===newUser.username;}).length;if(duplicateUser){reject('Username \"'+newUser.username+'\" is already taken');return;}// save new user\nnewUser.id=users.length?Math.max.apply(Math,_toConsumableArray(users.map(function(user){return user.id;})))+1:1;users.push(newUser);localStorage.setItem('users',JSON.stringify(users));// respond 200 OK\nresolve({ok:true,text:function text(){return Promise.resolve();}});return;}// delete user\nif(url.match(/\\/users\\/\\d+$/)&&opts.method==='DELETE'){// check for fake auth token in header and return user if valid, this security is implemented server side in a real application\nif(opts.headers&&opts.headers.Authorization==='Bearer fake-jwt-token'){// find user by id in users array\nvar _urlParts=url.split('/');var _id=parseInt(_urlParts[_urlParts.length-1]);for(var i=0;i<users.length;i++){var _user2=users[i];if(_user2.id===_id){// delete user\nusers.splice(i,1);localStorage.setItem('users',JSON.stringify(users));break;}}// respond 200 OK\nresolve({ok:true,text:function text(){return Promise.resolve();}});}else{// return 401 not authorised if token is null or invalid\nreject('Unauthorised');}return;}// pass through any requests not handled above\nrealFetch(url,opts).then(function(response){return resolve(response);});},500);});};}","map":{"version":3,"names":["users","JSON","parse","localStorage","getItem","configureFakeBackend","realFetch","window","fetch","url","opts","Promise","resolve","reject","setTimeout","endsWith","method","params","body","filteredUsers","filter","user","username","password","length","responseJson","id","firstName","lastName","token","ok","text","stringify","headers","Authorization","match","urlParts","split","parseInt","matchedUsers","newUser","duplicateUser","Math","max","map","push","setItem","i","splice","then","response"],"sources":["C:/Users/caleb/VSchildren/SCF/src/_helpers/fake-backend.js"],"sourcesContent":["// array in local storage for registered users\r\nlet users = JSON.parse(localStorage.getItem('users')) || [];\r\n    \r\nexport function configureFakeBackend() {\r\n    let realFetch = window.fetch;\r\n    window.fetch = function (url, opts) {\r\n        return new Promise((resolve, reject) => {\r\n            // wrap in timeout to simulate server api call\r\n            setTimeout(() => {\r\n\r\n                // authenticate\r\n                if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\r\n                    // get parameters from post request\r\n                    let params = JSON.parse(opts.body);\r\n\r\n                    // find if any user matches login credentials\r\n                    let filteredUsers = users.filter(user => {\r\n                        return user.username === params.username && user.password === params.password;\r\n                    });\r\n\r\n                    if (filteredUsers.length) {\r\n                        // if login details are valid return user details and fake jwt token\r\n                        let user = filteredUsers[0];\r\n                        let responseJson = {\r\n                            id: user.id,\r\n                            username: user.username,\r\n                            firstName: user.firstName,\r\n                            lastName: user.lastName,\r\n                            token: 'fake-jwt-token'\r\n                        };\r\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(responseJson)) });\r\n                    } else {\r\n                        // else return error\r\n                        reject('Username or password is incorrect');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // get users\r\n                if (url.endsWith('/users') && opts.method === 'GET') {\r\n                    // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\r\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\r\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(users))});\r\n                    } else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        reject('Unauthorised');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // get user by id\r\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\r\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\r\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\r\n                        // find user by id in users array\r\n                        let urlParts = url.split('/');\r\n                        let id = parseInt(urlParts[urlParts.length - 1]);\r\n                        let matchedUsers = users.filter(user => { return user.id === id; });\r\n                        let user = matchedUsers.length ? matchedUsers[0] : null;\r\n\r\n                        // respond 200 OK with user\r\n                        resolve({ ok: true, text: () => JSON.stringify(user)});\r\n                    } else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        reject('Unauthorised');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // register user\r\n                if (url.endsWith('/users/register') && opts.method === 'POST') {\r\n                    // get new user object from post body\r\n                    let newUser = JSON.parse(opts.body);\r\n\r\n                    // validation\r\n                    let duplicateUser = users.filter(user => { return user.username === newUser.username; }).length;\r\n                    if (duplicateUser) {\r\n                        reject('Username \"' + newUser.username + '\" is already taken');\r\n                        return;\r\n                    }\r\n\r\n                    // save new user\r\n                    newUser.id = users.length ? Math.max(...users.map(user => user.id)) + 1 : 1;\r\n                    users.push(newUser);\r\n                    localStorage.setItem('users', JSON.stringify(users));\r\n\r\n                    // respond 200 OK\r\n                    resolve({ ok: true, text: () => Promise.resolve() });\r\n\r\n                    return;\r\n                }\r\n\r\n                // delete user\r\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'DELETE') {\r\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\r\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\r\n                        // find user by id in users array\r\n                        let urlParts = url.split('/');\r\n                        let id = parseInt(urlParts[urlParts.length - 1]);\r\n                        for (let i = 0; i < users.length; i++) {\r\n                            let user = users[i];\r\n                            if (user.id === id) {\r\n                                // delete user\r\n                                users.splice(i, 1);\r\n                                localStorage.setItem('users', JSON.stringify(users));\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        // respond 200 OK\r\n                        resolve({ ok: true, text: () => Promise.resolve() });\r\n                    } else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        reject('Unauthorised');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // pass through any requests not handled above\r\n                realFetch(url, opts).then(response => resolve(response));\r\n\r\n            }, 500);\r\n        });\r\n    }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}